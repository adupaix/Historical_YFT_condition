#'#*******************************************************************************************************************
#'@author : Amael DUPAIX
#'@update : 2021-11-17
#'@email : amael.dupaix@ens-lyon.fr
#'#*******************************************************************************************************************
#'@description :  Third part of the main script to determine if the YFT condition factor (Kn) has been
#' impacted by the introduction of FADs in the Indian Ocean.
#' This part summarizes all the GAMs generated by the first part (and potentially by the second part, which runs on the cluster)
#'#*******************************************************************************************************************
#' @tags:
#' the @for_study tag is used before each argument, to specify which arguments were used to obtain the study results
#'#*******************************************************************************************************************
#'@revisions:
#' 2022/08/22: for submission as a Rapid communication in the Canadian Journal of Fisheries and Aquatic Science
#'             the ggplot noted fig1 becomes the panel A of Figure 2
#'             the ggplot noted fig2 is not used anymore
#'#*******************************************************************************************************************

rm(list = ls())
invisible(gc())

WD <- getwd()

DATA_PATH <- file.path(WD, "0.Data/")

FUNC_PATH <- file.path(WD,"1.Functions")
# OUTPUT_PATH <- file.path(WD, "3.Outputs", format(Sys.time()))
OUTPUT_PATH <- file.path(WD, "3.Outputs")
ROUT_PATH <- file.path(WD,"6.Sub-routines")

#'#**********
# Arguments ----
#'#**********
#' Name of the output folder which was generated by
#' the first part of the study (main.R & potentially main_cluster.R)
#' @for_study: "2022-01-31"
study_date = "2022-01-31"
# study_date = format(Sys.Date())
#' @for_study: "-whole_dataset"
output_suffixe = "-whole_dataset"
#' Arguments added on 2022-08-22, to generate figure 2 for submission in the Canadian JFAS
#' @for_study: canadian = T ; figure_dir = "2022-03-28-build_figures"
canadian = T
figure_dir = "2022-08-22-build_figures"


study_date <- paste0(study_date, output_suffixe)

#' Read the arguments of the first part of the study
arguments <- readRDS(file.path(OUTPUT_PATH, study_date, "README.rds"))
list2env(arguments, envir = .GlobalEnv)

#' ***************
# Initialize  ----
#' ***************
source(file.path(FUNC_PATH, "install_libraries.R"))

srcUsedPackages <- c("plyr", "dplyr","tidyr","lubridate","sf", "ggplot2","tibble",
                     "cowplot","RColorBrewer", "MASS", "mgcv", "abind", "ggpubr")

installAndLoad_packages(srcUsedPackages, loadPackages = TRUE, verbose = F)

#' Generate the names of the outputs
latlonPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "mean_npoints_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "mean_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "sd_latlon_plot.png"))
coefDfPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff_violin.png"))
plotListName <- file.path(OUTPUT_PATH, study_date, "global_plot_list.rds")
rSquareName <- file.path(OUTPUT_PATH, study_date, "r_squares.rds")
readName <- file.path(OUTPUT_PATH, study_date, "README.txt")
canadianFigName <- file.path(OUTPUT_PATH, study_date, "Plots", "canadian_fig2.png")

try(dir.create(file.path(OUTPUT_PATH, study_date, "Plots")))

#' source subfunctions
source(file.path(FUNC_PATH, "subfunctions.R"))

#' list all the GAMs (main.R generated one sub-directory per generated GAM)
dirs <- list.dirs(file.path(OUTPUT_PATH, study_date), recursive = F)
dirs <- dirs[-grep("Plots", dirs)]

# list of dataframes of predicted values by each model
ct_int_pred <- list()

# vector with the R2 (deviance explained)
r_squares <- c()

#' list the variables used in the GAMs
#' will allow to generate the prediction data frame
#'    List variables
vars_of_model <- c("fishing_year","fishing_quarter")
#'    Generate the file names (to save tables of coefficients)
coeffTableName <- c(file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_year.csv"),
                    file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_quarter.csv"))
pValTableName <- c(file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_year.csv"),
                   file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_quarter.csv"))
if (size_class_for_model == "all"){
  vars_of_model <- c(vars_of_model, "size_class")
  coeffTableName <- c(coeffTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_size_class.csv"))
  pValTableName <- c(pValTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_size_class.csv"))
}
if (fad_fsc == T & fishing_mode_for_model == "all"){
  vars_of_model <- c(vars_of_model, "fishing_mode")
  coeffTableName <- c(coeffTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_mode.csv"))
  pValTableName <- c(pValTableName,
                     file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_mode.csv"))
}

#' @test if the reference values chosen in the ref_var_values list can be used
#' if not (because the specified level is not present in the data)
#' the reference value is asked to the user and saved in README.txt
#' the test is performed on the first gam of the list
gam <- readRDS(file.path(dirs[1], grep("^gam.*rds", list.files(dirs[1]), value = T)))
data <- gam$model
append_readme = F
for (i in 1:length(vars_of_model)){
  level_is_present <- ref_var_values[[vars_of_model[i]]] %in% data[,vars_of_model[i]]
  if (!level_is_present){
    append_readme = T
    cat("The specified reference level for", vars_of_model[i], "is unappropriate\n")
    to_choose <- levels(data[,vars_of_model[i]])
    choice <- readline(prompt = paste0("Please choose the reference level among the following values:\n",paste(to_choose, collapse = " ; ")))
    while(!choice %in% to_choose & !as.numeric(choice) %in% 1:length(to_choose)){
      choice <- readline(prompt = paste0("Please choose the reference level among the following values:\n",paste(to_choose, collapse = " ; ")))
    }
    if (choice %in% to_choose){
      ref_var_values[[vars_of_model[i]]] <- choice
    } else if (as.numeric(choice) %in% 1:length(to_choose)){
      ref_var_values[[vars_of_model[i]]] <- to_choose[as.numeric(choice)]
    }
    
  }
}

if(append_readme){
  sink(readName, append = T)
  cat("\n\nmain_post_cluster.R\nExecuted on", format(Sys.time()), "\n\nref_var_values changed to: ")
  cat(paste(ref_var_values, collapse = " , "))
  sink()
}

# Read GAMs ----
coef.df <- list()
p.val.df <- list()
#' dataframe which will contain the coefficients of all the GAMs
#' give 100 columns and delete the empty columns afterwards (no need to provide the number of coefficient as argument)
for (k in 1:length(vars_of_model)){
  coef.df[[k]] <- data.frame(matrix(ncol = 100, nrow = 0))
  p.val.df[[k]] <- data.frame(matrix(ncol = 100, nrow = 0))
}
names(coef.df) <- vars_of_model ; names(p.val.df) <- vars_of_model

if (!(canadian & file.exists(plotListName))){
  if (cluster == F & VERBOSE == T){
    cat("Getting prediction from every model")
    
    pb <- txtProgressBar(max = length(dirs), style = 3)
  }
  
  for (i in 1:length(dirs)){
    
    if (cluster == F & VERBOSE == T){
      setTxtProgressBar(pb, i)
    }
    
    gam <- readRDS(file.path(dirs[i], grep("^gam.*rds", list.files(dirs[i]), value = T)))
    
    #'@r-square
    r_squares[i] <- summary(gam)$dev.expl
    
    #'@factor_terms
    coef <- coefficients(gam)[-grep("lon|lat", names(coefficients(gam)))]
    #'@significance of factor terms
    p.val <- summary(gam)$p.table[,4]
    
    for (k in 1:length(vars_of_model)){
      coef.df[[k]] <- rbind(coef.df[[k]], c(coef[grep(vars_of_model[k], names(coef))], rep(NA, 100-length(coef))))
      p.val.df[[k]] <- rbind(p.val.df[[k]], c(p.val[grep(vars_of_model[k], names(p.val))], rep(NA, 100-length(p.val))))
      if (length(grep(vars_of_model[k], names(coef), value = T)) !=0){
        names(coef.df[[k]]) <- grep(vars_of_model[k], names(coef), value = T)
        names(p.val.df[[k]]) <- grep(vars_of_model[k], names(p.val), value = T)
      }
    }
    
    #'@spatial_term
    data <- gam$model
    
    # get the gam prediction, for every lat lon pair
    ct_int_pred[[i]] <- expand_grid(
      lon = seq(from=xlm[1], 
                to=xlm[2], 
                length.out = xlm[2]-xlm[1]+1),
      lat = seq(from=ylm[1],
                to=ylm[2], 
                length.out = ylm[2]-ylm[1]+1)
    )
    
    # for every explanatory variable of the model, use the values chosen in the arguments
    for (k in 1:length(vars_of_model)){
      ct_int_pred[[i]] %>%
        dplyr::mutate(!!as.character(vars_of_model[k]) := ref_var_values[[vars_of_model[k]]]) -> ct_int_pred[[i]]
    }
    
    ct_int_pred[[i]] <- predict(gam, newdata = ct_int_pred[[i]], se.fit = TRUE) %>%  
      as_tibble() %>% 
      cbind(ct_int_pred[[i]]) %>%
      dplyr::select(fit, lon, lat)
    
    # get the number of samples per cell
    data %>% dplyr::mutate(lat_r = round(lat), lon_r = round(lon)) -> rdata
    
    table(rdata$lon_r, rdata$lat_r) %>% as.data.frame() %>%
      tidyr::expand_grid() %>%
      dplyr::rename("lon" = "Var1",
                    "lat" = "Var2",
                    "n_spl" = "Freq") %>%
      dplyr::mutate(lat = as.numeric(as.character(lat)),
                    lon = as.numeric(as.character(lon))) %>%
      as.data.frame() -> count_data
    
    merge(count_data, ct_int_pred[[i]], by = c("lon","lat"), all.y = T) %>%
      dplyr::mutate(n_spl = ifelse(is.na(n_spl), 0, n_spl)) -> ct_int_pred[[i]]
  }
  
  if (cluster == F & VERBOSE == T){
    close(pb)
  }
  
  for (k in 1:length(vars_of_model)){
    #'@factor_terms
    cols <- !apply(coef.df[[k]], 2, function(x) all(is.na(x)))
    coef.df[[k]] <- coef.df[[k]][,cols]
    
    #'@significance of factor terms
    cols <- !apply(p.val.df[[k]], 2, function(x) all(is.na(x)))
    p.val.df[[k]] <- p.val.df[[k]][,cols]
    
    #' @save the table with all the coefficients
    write.csv(x = coef.df[[k]], file = coeffTableName[k])
    #' @save the table with the p-values associated with all the coefficients
    write.csv(x = p.val.df[[k]], file = pValTableName[k])
  }
  
  
  # Build spatial prediction ----
  #' @spatial_term
  df_tot <- abind(ct_int_pred, along = 3)
  
  len = length(dirs)
  # len <- 500
  if(len!=length(dirs)){df_tot <- df_tot[,,1:len]}
  
  #' polygons of the land
  countries <- map_data("world")
  
  #' functions of the maps to be plotted
  # f <- c("mean","sd")
  # variable <- c("fit", "n_spl")
  
  df_list <- list()
  plot_list <- list()
  
  # df_nspl <- df_tot[,which(dimnames(df_tot)[[2]] == "n_spl"),]
  # df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
  df_lon <- df_tot[,which(dimnames(df_tot)[[2]] == "lon"),]
  df_lat <- df_tot[,which(dimnames(df_tot)[[2]] == "lat"),]
  
  if (any(apply(df_lon, 1, function(x) length(unique(x))) != 1)){
    stop("Error: longitudinal range is not the same for all the predictions")
  } else if (any(apply(df_lat, 1, function(x) length(unique(x))) != 1)){
    "Error: latitudinal range is not the same for all the predictions"
  }
  
  #' 1. Mean number of points per cell
  #' ******************************
  df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "n_spl"),]
  col_fit <- apply(df_fit, 1, "mean")
  col_lon <- df_lon[,1]
  col_lat <- df_lat[,1]
  
  
  # matrix with all the data
  df_list$nb_points <- as.data.frame(cbind(fit = col_fit,
                                           lon = col_lon,
                                           lat = col_lat))
  # data.frame where only the cells with 0 points are kept (to add a grey canvas around the fishing area)
  df_list$out_of_range <- df_list$nb_points %>% dplyr::filter(fit==0)
  
  # Plot
  plot_list[[1]] <- ggplot(data = df_list$nb_points, aes(x=lon, y=lat)) +
    coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
    geom_tile(aes(fill = fit), na.rm = T, color = "grey40") +
    scale_fill_gradientn("Mean number\nof samples", na.value = NA,
                         colors = c("blue","grey","red"),
                         trans = "log",
                         breaks = c(0.1,1,10,100))+
    geom_tile(data = df_list$out_of_range, aes(x=lon, y=lat), fill = "grey40", alpha = 1) +
    theme(panel.background = element_blank(),
          panel.border = element_rect(fill=NA))+
    geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
    xlab("Longitude")+ylab("Latitude")
  
  
  #' 2. Mean Predicted value
  #' *************************
  df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
  col_fit <- apply(df_fit, 1, "mean")
  col_lon <- df_lon[,1]
  col_lat <- df_lat[,1]
  
  # data frame with all the data
  df_list$mean <- as.data.frame(cbind(fit = col_fit,
                                      lon = col_lon,
                                      lat = col_lat))
  
  #' back-transform values if GAMs were performed on T(Kn)
  if(Kn_transformation){
    kn = seq(-1,2,0.001) # interval around the observed values of Kn
    
    global_data <- readRDS(file.path(OUTPUT_PATH, study_date, "df_filtered.rds"))
    
    tkn = geary.hinkley.transform(kn,
                                  global_data$weight_th,
                                  global_data$whole_fish_weight,
                                  cor.method = "pearson")
    
    correspondance <- data.frame(Kn = kn,
                                 T.Kn = tkn)
    
    df_list$mean$fit = mapply(back.transform, df_list$mean$fit, MoreArgs = list(correspondance = correspondance))
  }
  
  #' @plot
  plot_list[[2]] <- ggplot(df_list$mean, aes(x=lon, y=lat)) +
    geom_tile(aes(fill = fit), na.rm = T) +
    coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
    geom_tile(data = df_list$out_of_range, aes(x=lon, y=lat), fill = "grey40", alpha = 1) +
    scale_fill_gradientn("Mean\npredicted Kn",
                         na.value = NA,
                         colors = c("blue","grey","red"))+
    # geom_contour(aes(z = fit), binwidth = 0.05, colour = "grey60")+
    theme(panel.background = element_blank(),
          panel.border = element_rect(fill=NA))+
    geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
    xlab("Longitude")+ylab("Latitude")
  
  # 2. Sd Predicted value
  #' *************************
  df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
  col_fit <- apply(df_fit, 1, "sd")
  col_lon <- df_lon[,1]
  col_lat <- df_lat[,1]
  
  # data frame with all the data
  # data frame with NA where no points were sampled
  df_list$sd <- as.data.frame(cbind(fit = col_fit,
                                    lon = col_lon,
                                    lat = col_lat))
  
  # df_list[[6]] <- df_list$sd %>% dplyr::mutate(fit = ifelse(df_list[[1]]$fit == 0, NA, fit))
  
  #' @plot
  plot_list[[3]] <- ggplot(df_list$sd, aes(x=lon, y=lat)) +
    geom_tile(aes(fill = fit), alpha = 0.2, na.rm = T) +
    coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
    geom_tile(data = df_list$out_of_range, aes(x=lon, y=lat), fill = "grey40", alpha = 1) +
    scale_fill_gradientn(paste0("Sd of predicted\n", ifelse(Kn_transformation, "T(Kn)", "Kn")),
                         limits = c(0,
                                    max(df_list$sd$fit, na.rm = T)),
                         na.value = NA,
                         colors = c("blue","grey","red"))+
    # geom_contour(aes(z = fit), binwidth = 0.05, colour = "grey60")+
    theme(panel.background = element_blank(),
          panel.border = element_rect(fill=NA))+
    geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
    xlab("Longitude")+ylab("Latitude")
  
  for(i in 1:3){ggsave(latlonPlotNames[i], plot_list[[i]])}
  
  
  # Plot GAM coefficients ----
  
  #'******************************
  #' Plots of the GAM coefficients
  #'******************************
  data_filtered <- readRDS(file.path(OUTPUT_PATH, study_date, "df_filtered.rds"))
  
  lev <- levels(data_filtered$fishing_year)
  #' in case the dataset used for the model is the dataset of one size class only or the one with fishing_mode
  #' the gam was performed on a subset of the data_filtered dataset. The levels of the explanatory variables
  #' can then differ. So we take the ones from the GAM dataset (saved in gam$model)
  if (fad_fsc | size_class_for_model != "all"){lev <- sort(levels(data$fishing_year))}
  p1 <- plot.coef.df(coef.df, p.val.df, "fishing_year", levels = lev,
                     level_ref = as.character(ref_var_values$fishing_year),
                     labelx = "Year",
                     output_path = file.path(OUTPUT_PATH, study_date))
  
  lev <- levels(data_filtered$fishing_quarter)
  if (fad_fsc | size_class_for_model != "all"){lev <- levels(data$fishing_quarter)}
  p2 <- plot.coef.df(coef.df, p.val.df, "fishing_quarter", levels = lev,
                     level_ref = as.character(ref_var_values$fishing_quarter),
                     labelx = "Quarter",
                     output_path = file.path(OUTPUT_PATH, study_date))
  
  ggsave(coefDfPlotNames[1], p1[[1]])
  ggsave(coefDfPlotNames[2], p1[[2]])
  ggsave(coefDfPlotNames[3], p2[[1]])
  ggsave(coefDfPlotNames[4], p2[[2]])
  
  global_plot_list <- list(plot_list[[1]], plot_list[[2]],
                           plot_list[[3]],
                           p1[[1]],p1[[2]],
                           p2[[1]],p2[[2]])
  
  if (size_class_for_model == 'all'){
    p3 <- plot.coef.df(coef.df, p.val.df, "size_class", levels = size_class_levels,
                       level_ref = as.character(ref_var_values$size_class),
                       labelx = "Size Class",
                       output_path = file.path(OUTPUT_PATH, study_date))
    ggsave(coefDfPlotNames[5], p3[[1]])
    ggsave(coefDfPlotNames[6], p3[[2]])
    
    global_plot_list <- append(global_plot_list, list(p3[[1]], p3[[2]]))
  }
  
  if (fad_fsc == T & fishing_mode_for_model == "all"){
    data$fishing_mode[which(data$fishing_mode == "DFAD")] <- "FOB"
    lev <- levels(data$fishing_mode)
    p4 <- plot.coef.df(coef.df, p.val.df, "fishing_mode",
                       levels = lev, level_ref = ref_var_values$fishing_mode,
                       labelx = "School Type",
                       output_path = file.path(OUTPUT_PATH, study_date))
    ggsave(coefDfPlotNames[7], p4[[1]])
    ggsave(coefDfPlotNames[8], p4[[2]])
    
    global_plot_list <- append(global_plot_list, list(p4[[1]], p4[[2]]))
  }
  
  
  # Save ----
  #' Save the list with all the ggplots
  saveRDS(global_plot_list, plotListName)
  
  #' Save the r-squares vector
  saveRDS(r_squares, rSquareName)
  
} else {

  # Panel A
  panelA <- readRDS(file.path(OUTPUT_PATH, figure_dir, "Plots", "Figure1.rds"))
  
  #' get holes in data, to plot a vertical line
  #'  @!!: these lines are necessary to properly plot fig1, which uses line_pose as an argument (line_pos in not defined in this environment)
  diff_following_years <- lead(as.numeric(levels(as.factor(panelA$data$fishing_year)))) - as.numeric(levels(as.factor(panelA$data$fishing_year)))
  line_pos = which(diff_following_years != 1)+0.5
  panelA <- panelA +
    theme(axis.title.x = element_blank(),
          axis.text.x = element_blank(),
          axis.ticks.x = element_blank(),
          legend.position = "top",
          axis.title.y = element_text(size = 12))
  
  
  #' Panel B
  global_plot_list <- readRDS(plotListName)
  panelB <- global_plot_list[[5]]
  panelB <- panelB +
    geom_vline(aes(xintercept = line_pos)) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1),
          panel.border = element_rect(color = "black", fill = NA),
          axis.text = element_text(size = 12),
          axis.title = element_text(size = 12))
  
  canadian_fig2 <- ggpubr::ggarrange(panelA, panelB,
                                     nrow = 2,
                                     labels = "AUTO")
  ggsave(canadianFigName,
         canadian_fig2,
         width = 175,
         height = 237,
         units = "mm")
}

#'#*******************************************************************************************************************
#'@author : Amael DUPAIX
#'@update : 2021-11-17
#'@email : amael.dupaix@ens-lyon.fr
#'#*******************************************************************************************************************
#'@description :  Third part of the main script to determine if the YFT condition factor (Kn) has been
#' impacted by the introduction of FADs in the Indian Ocean.
#' This part summarizes all the GAMs generated by the first part (and potentially by the second part, which runs on the cluster)
#'#*******************************************************************************************************************
#' @tags:
#' the @for_study tag is used before each argument, to specify which arguments were used to obtain the study results
#'#*******************************************************************************************************************
#'@revisions
#'#*******************************************************************************************************************

rm(list = ls())
invisible(gc())

WD <- getwd()

DATA_PATH <- file.path(WD, "0.Data/")

FUNC_PATH <- file.path(WD,"1.Functions")
# OUTPUT_PATH <- file.path(WD, "3.Outputs", format(Sys.time()))
OUTPUT_PATH <- file.path(WD, "3.Outputs")
ROUT_PATH <- file.path(WD,"6.Sub-routines")

PLOT_PATH <- file.path(OUTPUT_PATH, "Plots")

#'@arguments:
#'#**********
#'
#' Name of the output folder which was generated by
#' the first part of the study (main.R & potentially main_cluster.R)
#' @for_study: format(Sys.Date())
study_date = "2021-11-23"
# study_date = format(Sys.Date())

#' Read the arguments of the first part of the study
arguments <- readRDS(file.path(OUTPUT_PATH, study_date, "README.rds"))
list2env(arguments, envir = .GlobalEnv)

#' If want to change the color scale limits compared to the one used in the main.R script
#' if NULL, the limits are c(0.9,1.1) if the GH transformation is not applied
#'                     or c(-1,1) if the GH transformation is applied
#' @for_study: c(-1,0)
smooth_col_limits = c(-1,0)
# smooth_col_limits = c(-1,0)

#' Values of the explanatory variables chosen to make the spatial prediction
#' @for_study: predict_var_values = list(fishing_quarter = "1",
#'                                       fishing_year = 2008,
#'                                       size_class = "<75")
#'                                       
predict_var_values = list(fishing_quarter = "1",
                          fishing_year = 1987,
                          size_class = "<75")

#' ***************
#' Get libraries:
#' ***************
source(file.path(FUNC_PATH, "install_libraries.R"))

srcUsedPackages <- c("plyr", "dplyr","tidyr","lubridate","sf", "ggplot2","tibble",
                     "cowplot","RColorBrewer", "MASS","truncnorm", "mgcv", "abind")

installAndLoad_packages(srcUsedPackages, loadPackages = TRUE, verbose = F)

# Generate the names of the outputs
latlonPlotNames <- c(file.path(OUTPUT_PATH, study_date, "mean_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "sd_latlon_plot.png"))
coefDfPlotNames <- c(file.path(OUTPUT_PATH, study_date, "year_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "year_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "quarter_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "quarter_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "size_class_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "size_class_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "fishing_mode_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "fishing_mode_coeff_violin.png"))
coeffTableName <- file.path(OUTPUT_PATH, study_date, "coeff_table.csv")

#' source subfunctions
source(file.path(FUNC_PATH, "subfunctions.R"))

#' list all the GAMs (main.R generated one sub-directory per generated GAM)
dirs <- list.dirs(file.path(OUTPUT_PATH, study_date), recursive = F)
dirs <- dirs[-grep("Plots", dirs)]

#' dataframe which will contain the coefficients of all the GAMs
#' give 100 columns and delete the empty columns afterwards (no need to provide the number of coefficient as argument)
coef.df <- data.frame(matrix(ncol = 100, nrow = 0))

# list of dataframes of predicted values by each model
ct_int_pred <- list()

cat("Getting prediction from every model")

pb <- txtProgressBar(max = length(dirs), style = 3)

for (i in 1:length(dirs)){
  
  setTxtProgressBar(pb, i)
  
  gam <- readRDS(file.path(dirs[i], grep("gam.*rds", list.files(dirs[i]), value = T)))
  
  #'@factor_terms
  coef <- coefficients(gam)[-grep("lon|lat", names(coefficients(gam)))]
  coef.df <- rbind(coef.df, c(coef, rep(NA, 100-length(coef))))
  names(coef.df) <- names(coef)
  
  #'@spatial_term
  data <- gam$model
  
  # get the gam prediction, for every lat lon pair
  # with, for every other variable, the values chosen in the arguments
  ct_int_pred[[i]] <- expand_grid(
    lon = seq(from=xlm[1], 
              to=xlm[2], 
              length.out = 50),
    lat = seq(from=ylm[1],
              to=ylm[2], 
              length.out = 50),
    fishing_quarter = predict_var_values$fishing_quarter,
    fishing_year = predict_var_values$fishing_year,
    size_class = predict_var_values$size_class
  )
  
  ct_int_pred[[i]] <- predict(gam, newdata = ct_int_pred[[i]], se.fit = TRUE) %>%  
    as_tibble() %>% 
    cbind(ct_int_pred[[i]]) %>%
    dplyr::select(fit, lon, lat)
  
}

close(pb)

#'@factor_terms
cols <- !apply(coef.df, 2, function(x) all(is.na(x)))
coef.df <- coef.df[,cols]

#' @save the table with all the coefficients
write.csv(x = coef.df, file = coeffTableName)

#' @spatial_term
df_tot <- abind(ct_int_pred, along = 3)

len = length(dirs)
# len <- 500
if(len!=length(dirs)){df_tot <- df_tot[,,1:len]}

  #' limits of the colour scale and binwidth of the level lines
if (is.null(smooth_col_limits)){
  if(Kn_transformation){
    lims <- list(c(-1,1),
                 c(0,.1))
    bwidth <- c(0.25,0.125)
  } else {
    lims <- list(c(0.9,1.1),
                 c(0,.1))
    bwidth <- c(0.025,0.0125)
  }
} else {
  lims <- list(smooth_col_limits,
               c(0,.1))
  bwidth <- c((lims[[1]][2]-lims[[1]][1])/8,
              (lims[[2]][2]-lims[[2]][1])/8)
}

col_titles <- paste(c("Mean","Sd of"), paste0("predicted\n",ifelse(Kn_transformation, "T(Kn)", "Kn")))

  #' polygons of the land
countries <- map_data("world")

  #' functions of the maps to be plotted
f <- c("mean","sd")

df_list <- list()
plot_list <- list()

df_fit <- df_tot[,1,]
df_lon <- df_tot[,2,]
df_lat <- df_tot[,3,]

if (any(apply(df_lon, 1, function(x) length(unique(x))) != 1)){
  stop("Error: longitudinal range is not the same for all the predictions")
} else if (any(apply(df_lat, 1, function(x) length(unique(x))) != 1)){
  "Error: latitudinal range is not the same for all the predictions"
}

for (k in 1:length(f)){
  
  col_fit <- apply(df_fit, 1, f[k])
  col_lon <- df_lon[,1]
  col_lat <- df_lat[,1]
  
  df_list[[f[k]]] <- as.data.frame(cbind(fit = col_fit,
                                         lon = col_lon,
                                         lat = col_lat))
  
  
  #' @plot
  plot_list[[f[k]]] <- ggplot(df_list[[f[k]]], aes(x=lon, y=lat)) +
    coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
    geom_tile(aes(fill = fit), alpha = 0.8) +
    scale_fill_gradientn(col_titles[k], limits = lims[[k]], colors = c("blue","grey","red"))+
    geom_contour(aes(z = fit), binwidth = bwidth[k], colour = "grey40")+
    theme(panel.background = element_blank(),
          panel.border = element_rect(fill=NA))+
    geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
    xlab("Longitude")+ylab("Latitude")
  
  ggsave(latlonPlotNames[k], plot_list[[f[k]]])
  ggsave(paste0(latlonPlotNames[k],len,".png"), plot_list[[f[k]]])
}

# rm(col_fit, col_lon, col_lat, df_fit, df_lon, df_lat) ; invisible(gc())


#'******************************
#' Plots of the GAM coefficients
#'******************************
p1 <- plot.coef.df(coef.df, "fishing_year", labelx = "Year")
p2 <- plot.coef.df(coef.df, "fishing_quarter", labelx = "Quarter")

ggsave(coefDfPlotNames[1], p1[[1]])
ggsave(coefDfPlotNames[2], p1[[2]])
ggsave(coefDfPlotNames[3], p2[[1]])
ggsave(coefDfPlotNames[4], p2[[2]])

if (size_class_for_model == 'all'){
  p3 <- plot.coef.df(coef.df, "size_class", levels_order = size_class_levels[-1], labelx = "Size Class")
  ggsave(coefDfPlotNames[5], p3[[1]])
  ggsave(coefDfPlotNames[6], p3[[2]])
}

if (fad_fsc == T & fishing_mode_for_model == "all"){
  p4 <- plot.coef.df(coef.df, "fishing_mode", labelx = "School Type")
  ggsave(coefDfPlotNames[7], p4[[1]])
  ggsave(coefDfPlotNames[8], p4[[2]])
}

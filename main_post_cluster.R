#'#*******************************************************************************************************************
#'@author : Amael DUPAIX
#'@update : 2021-11-17
#'@email : amael.dupaix@ens-lyon.fr
#'#*******************************************************************************************************************
#'@description :  Third part of the main script to determine if the YFT condition factor (Kn) has been
#' impacted by the introduction of FADs in the Indian Ocean.
#' This part summarizes all the GAMs generated by the first part (and potentially by the second part, which runs on the cluster)
#'#*******************************************************************************************************************
#' @tags:
#' the @for_study tag is used before each argument, to specify which arguments were used to obtain the study results
#'#*******************************************************************************************************************
#'@revisions
#'#*******************************************************************************************************************

rm(list = ls())
invisible(gc())

WD <- getwd()

DATA_PATH <- file.path(WD, "0.Data/")

FUNC_PATH <- file.path(WD,"1.Functions")
# OUTPUT_PATH <- file.path(WD, "3.Outputs", format(Sys.time()))
OUTPUT_PATH <- file.path(WD, "3.Outputs")
ROUT_PATH <- file.path(WD,"6.Sub-routines")

PLOT_PATH <- file.path(OUTPUT_PATH, "Plots")

#'@arguments:
#'#**********
#'
#' Name of the output folder which was generated by
#' the first part of the study (main.R & potentially main_cluster.R)
study_date = "2021-12-21"
output_suffixe = "-fishing_mode"
# study_date = format(Sys.Date())

study_date <- paste0(study_date, output_suffixe)

#' Read the arguments of the first part of the study
arguments <- readRDS(file.path(OUTPUT_PATH, study_date, "README.rds"))
list2env(arguments, envir = .GlobalEnv)

#' ***************
#' Get libraries:
#' ***************
source(file.path(FUNC_PATH, "install_libraries.R"))

srcUsedPackages <- c("plyr", "dplyr","tidyr","lubridate","sf", "ggplot2","tibble",
                     "cowplot","RColorBrewer", "MASS","truncnorm", "mgcv", "abind")

installAndLoad_packages(srcUsedPackages, loadPackages = TRUE, verbose = F)

# Generate the names of the outputs
latlonPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "mean_npoints_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "mean_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "sd_latlon_plot.png"))
coefDfPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff_violin.png"))
plotListName <- file.path(OUTPUT_PATH, study_date, "global_plot_list.rds")
rSquareName <- file.path(OUTPUT_PATH, study_date, "r_squares.rds")
readName <- file.path(OUTPUT_PATH, study_date, "README.txt")

try(dir.create(file.path(OUTPUT_PATH, study_date, "Plots")))

#' source subfunctions
source(file.path(FUNC_PATH, "subfunctions.R"))

#' list all the GAMs (main.R generated one sub-directory per generated GAM)
dirs <- list.dirs(file.path(OUTPUT_PATH, study_date), recursive = F)
dirs <- dirs[-grep("Plots", dirs)]

# list of dataframes of predicted values by each model
ct_int_pred <- list()

# vector with the R2 (deviance explained)
r_squares <- c()

#' list the variables used in the GAMs
#' will allow to generate the prediction data frame
#'    List variables
vars_of_model <- c("fishing_year","fishing_quarter")
#'    Generate the file names (to save tables of coefficients)
coeffTableName <- c(file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_year.csv"),
                    file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_quarter.csv"))
pValTableName <- c(file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_year.csv"),
                   file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_quarter.csv"))
if (size_class_for_model == "all"){
  vars_of_model <- c(vars_of_model, "size_class")
  coeffTableName <- c(coeffTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_size_class.csv"))
  pValTableName <- c(pValTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_size_class.csv"))
}
if (fad_fsc == T & fishing_mode_for_model == "all"){
  vars_of_model <- c(vars_of_model, "fishing_mode")
  coeffTableName <- c(coeffTableName,
                      file.path(OUTPUT_PATH, study_date, "coeff_table_fishing_mode.csv"))
  pValTableName <- c(pValTableName,
                     file.path(OUTPUT_PATH, study_date, "coeff_table_p-values_fishing_mode.csv"))
}

#' @test if the reference values chosen in the ref_var_values list can be used
#' if not (because the specified level is not present in the data)
#' the reference value is asked to the user and saved in README.txt
#' the test is performed on the first gam of the list
gam <- readRDS(file.path(dirs[1], grep("gam.*rds", list.files(dirs[1]), value = T)))
data <- gam$model
append_readme = F
for (i in 1:length(vars_of_model)){
  level_is_present <- ref_var_values[[vars_of_model[i]]] %in% data[,vars_of_model[i]]
  if (!level_is_present){
    append_readme = T
    cat("The specified reference level for", vars_of_model[i], "is unappropriate\n")
    to_choose <- levels(data[,vars_of_model[i]])
    choice <- readline(prompt = paste0("Please choose the reference level among the following values:\n",paste(to_choose, collapse = " ; ")))
    while(!choice %in% to_choose & !as.numeric(choice) %in% 1:length(to_choose)){
      choice <- readline(prompt = paste0("Please choose the reference level among the following values:\n",paste(to_choose, collapse = " ; ")))
    }
    if (choice %in% to_choose){
      ref_var_values[[vars_of_model[i]]] <- choice
    } else if (as.numeric(choice) %in% 1:length(to_choose)){
      ref_var_values[[vars_of_model[i]]] <- to_choose[as.numeric(choice)]
    }
    
  }
}

if(append_readme){
  sink(readName, append = T)
  cat("\n\nmain_post_cluster.R\nExecuted on", format(Sys.time()), "\n\nref_var_values changed to: ")
  cat(paste(ref_var_values, collapse = " , "))
  sink()
}

coef.df <- list()
p.val.df <- list()
#' dataframe which will contain the coefficients of all the GAMs
#' give 100 columns and delete the empty columns afterwards (no need to provide the number of coefficient as argument)
for (k in 1:length(vars_of_model)){
  coef.df[[k]] <- data.frame(matrix(ncol = 100, nrow = 0))
  p.val.df[[k]] <- data.frame(matrix(ncol = 100, nrow = 0))
}
names(coef.df) <- vars_of_model ; names(p.val.df) <- vars_of_model


if (cluster == F & VERBOSE == T){
  cat("Getting prediction from every model")
  
  pb <- txtProgressBar(max = length(dirs), style = 3)
}

for (i in 1:length(dirs)){
  
  if (cluster == F & VERBOSE == T){
    setTxtProgressBar(pb, i)
  }
  
  gam <- readRDS(file.path(dirs[i], grep("gam.*rds", list.files(dirs[i]), value = T)))
  
  #'@r-square
  r_squares[i] <- summary(gam)$dev.expl
  
  #'@factor_terms
  coef <- coefficients(gam)[-grep("lon|lat", names(coefficients(gam)))]
  #'@significance of factor terms
  p.val <- summary(gam)$p.table[,4]
  
  for (k in 1:length(vars_of_model)){
    coef.df[[k]] <- rbind(coef.df[[k]], c(coef[grep(vars_of_model[k], names(coef))], rep(NA, 100-length(coef))))
    p.val.df[[k]] <- rbind(p.val.df[[k]], c(p.val[grep(vars_of_model[k], names(p.val))], rep(NA, 100-length(p.val))))
    if (length(grep(vars_of_model[k], names(coef), value = T)) !=0){
      names(coef.df[[k]]) <- grep(vars_of_model[k], names(coef), value = T)
      names(p.val.df[[k]]) <- grep(vars_of_model[k], names(p.val), value = T)
    }
  }
  
  #'@spatial_term
  data <- gam$model
  
  # get the gam prediction, for every lat lon pair
  ct_int_pred[[i]] <- expand_grid(
    lon = seq(from=xlm[1], 
              to=xlm[2], 
              length.out = xlm[2]-xlm[1]+1),
    lat = seq(from=ylm[1],
              to=ylm[2], 
              length.out = ylm[2]-ylm[1]+1)
  )
  
  # for every explanatory variable of the model, use the values chosen in the arguments
  for (k in 1:length(vars_of_model)){
    ct_int_pred[[i]] %>%
      mutate(!!as.character(vars_of_model[k]) := ref_var_values[[vars_of_model[k]]]) -> ct_int_pred[[i]]
  }
  
  ct_int_pred[[i]] <- predict(gam, newdata = ct_int_pred[[i]], se.fit = TRUE) %>%  
    as_tibble() %>% 
    cbind(ct_int_pred[[i]]) %>%
    dplyr::select(fit, lon, lat)
  
  # get the number of samples per cell
  data %>% mutate(lat_r = round(lat), lon_r = round(lon)) -> rdata
  
  table(rdata$lon_r, rdata$lat_r) %>% as.data.frame() %>%
    expand_grid() %>%
    rename("lon" = "Var1",
           "lat" = "Var2",
           "n_spl" = "Freq") %>%
    mutate(lat = as.numeric(as.character(lat)),
           lon = as.numeric(as.character(lon))) %>%
    as.data.frame() -> count_data
  
  merge(count_data, ct_int_pred[[i]], by = c("lon","lat"), all.y = T) %>%
    mutate(n_spl = ifelse(is.na(n_spl), 0, n_spl)) -> ct_int_pred[[i]]
}

if (cluster == F & VERBOSE == T){
  close(pb)
}

for (k in 1:length(vars_of_model)){
#'@factor_terms
  cols <- !apply(coef.df[[k]], 2, function(x) all(is.na(x)))
  coef.df[[k]] <- coef.df[[k]][,cols]
  
#'@significance of factor terms
  cols <- !apply(p.val.df[[k]], 2, function(x) all(is.na(x)))
  p.val.df[[k]] <- p.val.df[[k]][,cols]
  
#' @save the table with all the coefficients
  write.csv(x = coef.df[[k]], file = coeffTableName[k])
#' @save the table with the p-values associated with all the coefficients
  write.csv(x = p.val.df[[k]], file = pValTableName[k])
}


#' @spatial_term
df_tot <- abind(ct_int_pred, along = 3)

len = length(dirs)
# len <- 500
if(len!=length(dirs)){df_tot <- df_tot[,,1:len]}

  #' limits of the colour scale and binwidth of the level lines
if (is.null(smooth_col_limits)){
  if(Kn_transformation){
    lims <- list(c(-0.3,0.3),
                 NULL,
                 c(0,.1),
                 NULL)
    bwidth <- c(0.1,NA,0.01,NA)
    # bwidth <- c(0.1,NA,0.125,NA)
  } else {
    lims <- list(c(0.9,1.1),
                 NULL,
                 c(0,.1),
                 NULL)
    bwidth <- c(0.025, NA, 0.0125,NA)
  }
} else {
  lims <- list(smooth_col_limits,
               NULL,
               c(0,.1),
               NULL)
  bwidth <- c((lims[[1]][2]-lims[[1]][1])/8,
              NA,
              (lims[[2]][2]-lims[[2]][1])/8,
              NA)
}

col_titles <- paste(rep(c("Mean","Sd of"),each = 2),
                    c(paste0("predicted\n",ifelse(Kn_transformation, "T(Kn)", "Kn")),
                      "number\n of samples"))

  #' polygons of the land
countries <- map_data("world")

  #' functions of the maps to be plotted
# f <- c("mean","sd")
# variable <- c("fit", "n_spl")

df_list <- list()
plot_list <- list()

# df_nspl <- df_tot[,which(dimnames(df_tot)[[2]] == "n_spl"),]
# df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
df_lon <- df_tot[,which(dimnames(df_tot)[[2]] == "lon"),]
df_lat <- df_tot[,which(dimnames(df_tot)[[2]] == "lat"),]

if (any(apply(df_lon, 1, function(x) length(unique(x))) != 1)){
  stop("Error: longitudinal range is not the same for all the predictions")
} else if (any(apply(df_lat, 1, function(x) length(unique(x))) != 1)){
  "Error: latitudinal range is not the same for all the predictions"
}

#' 1. Mean number of points per cell
#' ******************************
df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "n_spl"),]
col_fit <- apply(df_fit, 1, "mean")
col_lon <- df_lon[,1]
col_lat <- df_lat[,1]


  # matrix with all the data
df_list[[1]] <- as.data.frame(cbind(fit = col_fit,
                                    lon = col_lon,
                                    lat = col_lat))
  # data.frame where only the cells with 0 points are kept (to add a grey canvas around the fishing area)
df_list[[2]] <- df_list[[1]] %>% filter(fit==0)

# Plot
plot_list[[1]] <- ggplot(data = df_list[[1]], aes(x=lon, y=lat)) +
  coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
  geom_tile(aes(fill = fit), na.rm = T, color = "grey40") +
  scale_fill_gradientn("Mean number\nof samples", na.value = NA,
                       colors = c("blue","grey","red"))+
  geom_tile(data = df_list[[2]], aes(x=lon, y=lat), fill = "grey40", alpha = 1) +
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill=NA))+
  geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
  xlab("Longitude")+ylab("Latitude")


#' 2. Mean Predicted value
#' *************************
df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
col_fit <- apply(df_fit, 1, "mean")
col_lon <- df_lon[,1]
col_lat <- df_lat[,1]
    
# data frame with all the data
df_list[[3]] <- as.data.frame(cbind(fit = col_fit,
                                    lon = col_lon,
                                    lat = col_lat))
# data frame with NA where no points were sampled
df_list[[4]] <- df_list[[3]] %>% mutate(fit = ifelse(df_list[[1]]$fit == 0, NA, fit))
  
  
#' @plot
plot_list[[2]] <- ggplot(df_list[[3]], aes(x=lon, y=lat)) +
  coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
  geom_tile(data = df_list[[4]], aes(x=lon, y=lat, fill = fit), alpha = 1) +
  geom_tile(aes(fill = fit), alpha = 0.4, na.rm = T) +
  scale_fill_gradientn(paste0("Mean predicted\n", ifelse(Kn_transformation, "T(Kn)", "Kn")),
                       na.value = NA,
                       colors = c("blue","grey","red"))+
  # geom_contour(aes(z = fit), binwidth = 0.05, colour = "grey60")+
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill=NA))+
  geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
  xlab("Longitude")+ylab("Latitude")

#' 2. Sd Predicted value
#' *************************
df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
col_fit <- apply(df_fit, 1, "sd")
col_lon <- df_lon[,1]
col_lat <- df_lat[,1]

# data frame with all the data
# data frame with NA where no points were sampled
df_list[[5]] <- as.data.frame(cbind(fit = col_fit,
                                    lon = col_lon,
                                    lat = col_lat))

df_list[[6]] <- df_list[[5]] %>% mutate(fit = ifelse(df_list[[1]]$fit == 0, NA, fit))


#' @plot
plot_list[[3]] <- ggplot(df_list[[5]], aes(x=lon, y=lat)) +
  coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
  geom_tile(data = df_list[[6]], aes(x=lon, y=lat, fill = fit), alpha = 1) +
  geom_tile(aes(fill = fit), alpha = 0.2, na.rm = T) +
  scale_fill_gradientn(paste0("Sd of predicted\n", ifelse(Kn_transformation, "T(Kn)", "Kn")),
                       limits = c(0,
                                  max(df_list[[6]]$fit, na.rm = T)),
                       na.value = NA,
                       colors = c("blue","grey","red"))+
  # geom_contour(aes(z = fit), binwidth = 0.05, colour = "grey60")+
  theme(panel.background = element_blank(),
        panel.border = element_rect(fill=NA))+
  geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
  xlab("Longitude")+ylab("Latitude")

for(i in 1:3){ggsave(latlonPlotNames[i], plot_list[[i]])}


#'******************************
#' Plots of the GAM coefficients
#'******************************
data_filtered <- readRDS(file.path(OUTPUT_PATH, study_date, "df_filtered.rds"))

lev <- levels(data_filtered$fishing_year)
#' in case the dataset used for the model is the dataset of one size class only or the one with fishing_mode
#' the gam was performed on a subset of the data_filtered dataset. The levels of the explanatory variables
#' can then differ. So we take the ones from the GAM dataset (saved in gam$model)
if (fad_fsc | size_class_for_model != "all"){lev <- sort(levels(data$fishing_year))}
p1 <- plot.coef.df(coef.df, p.val.df, "fishing_year", levels = lev,
                   level_ref = as.character(ref_var_values$fishing_year),
                   labelx = "Year",
                   output_path = file.path(OUTPUT_PATH, study_date))

lev <- levels(data_filtered$fishing_quarter)
if (fad_fsc | size_class_for_model != "all"){lev <- levels(data$fishing_quarter)}
p2 <- plot.coef.df(coef.df, p.val.df, "fishing_quarter", levels = lev,
                   level_ref = as.character(ref_var_values$fishing_quarter),
                   labelx = "Quarter",
                   output_path = file.path(OUTPUT_PATH, study_date))

ggsave(coefDfPlotNames[1], p1[[1]])
ggsave(coefDfPlotNames[2], p1[[2]])
ggsave(coefDfPlotNames[3], p2[[1]])
ggsave(coefDfPlotNames[4], p2[[2]])

global_plot_list <- list(plot_list[[1]], plot_list[[2]],
                         plot_list[[3]],
                         p1[[1]],p1[[2]],
                         p2[[1]],p2[[2]])

if (size_class_for_model == 'all'){
  p3 <- plot.coef.df(coef.df, p.val.df, "size_class", levels = size_class_levels,
                     level_ref = as.character(ref_var_values$size_class),
                     labelx = "Size Class",
                     output_path = file.path(OUTPUT_PATH, study_date))
  ggsave(coefDfPlotNames[5], p3[[1]])
  ggsave(coefDfPlotNames[6], p3[[2]])
  
  global_plot_list <- append(global_plot_list, list(p3[[1]], p3[[2]]))
}

if (fad_fsc == T & fishing_mode_for_model == "all"){
  lev <- levels(data$fishing_mode)
  p4 <- plot.coef.df(coef.df, p.val.df, "fishing_mode",
                     levels = lev, level_ref = ref_var_values$fishing_mode,
                     labelx = "School Type",
                     output_path = file.path(OUTPUT_PATH, study_date))
  ggsave(coefDfPlotNames[7], p4[[1]])
  ggsave(coefDfPlotNames[8], p4[[2]])
  
  global_plot_list <- append(global_plot_list, list(p4[[1]], p4[[2]]))
}


#' Save the list with all the ggplots
saveRDS(global_plot_list, plotListName)

#' Save the r-squares vector
saveRDS(r_squares, rSquareName)

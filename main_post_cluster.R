#'#*******************************************************************************************************************
#'@author : Amael DUPAIX
#'@update : 2021-11-17
#'@email : amael.dupaix@ens-lyon.fr
#'#*******************************************************************************************************************
#'@description :  Third part of the main script to determine if the YFT condition factor (Kn) has been
#' impacted by the introduction of FADs in the Indian Ocean.
#' This part summarizes all the GAMs generated by the first part (and potentially by the second part, which runs on the cluster)
#'#*******************************************************************************************************************
#' @tags:
#' the @for_study tag is used before each argument, to specify which arguments were used to obtain the study results
#'#*******************************************************************************************************************
#'@revisions
#'#*******************************************************************************************************************

rm(list = ls())
invisible(gc())

WD <- getwd()

DATA_PATH <- file.path(WD, "0.Data/")

FUNC_PATH <- file.path(WD,"1.Functions")
# OUTPUT_PATH <- file.path(WD, "3.Outputs", format(Sys.time()))
OUTPUT_PATH <- file.path(WD, "3.Outputs")
ROUT_PATH <- file.path(WD,"6.Sub-routines")

PLOT_PATH <- file.path(OUTPUT_PATH, "Plots")

#'@arguments:
#'#**********
#'
#' Name of the output folder which was generated by
#' the first part of the study (main.R & potentially main_cluster.R)
#' @for_study: format(Sys.Date())
study_date = "2021-12-06-whole_dataset"
# study_date = format(Sys.Date())

#' Read the arguments of the first part of the study
arguments <- readRDS(file.path(OUTPUT_PATH, study_date, "README.rds"))
list2env(arguments, envir = .GlobalEnv)

#' Values of the explanatory variables chosen to make the spatial prediction
#' @for_study: predict_var_values = list(fishing_quarter = "1",
#'                                       fishing_year = 2008,
#'                                       size_class = "<75")
#'                                       
predict_var_values = list(fishing_quarter = "1",
                          fishing_year = 2008,
                          size_class = "<75")

#' ***************
#' Get libraries:
#' ***************
source(file.path(FUNC_PATH, "install_libraries.R"))

srcUsedPackages <- c("plyr", "dplyr","tidyr","lubridate","sf", "ggplot2","tibble",
                     "cowplot","RColorBrewer", "MASS","truncnorm", "mgcv", "abind")

installAndLoad_packages(srcUsedPackages, loadPackages = TRUE, verbose = F)

# Generate the names of the outputs
latlonPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "mean_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "mean_npoints_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "sd_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "sd_npoints_latlon_plot.png"))
coefDfPlotNames <- c(file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "year_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "quarter_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "size_class_coeff_violin.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "Plots", "fishing_mode_coeff_violin.png"))
coeffTableName <- file.path(OUTPUT_PATH, study_date, "coeff_table.csv")
plotListName <- file.path(OUTPUT_PATH, study_date, "global_plot_list.rds")
rSquareName <- file.path(OUTPUT_PATH, study_date, "r_squares.rds")

try(dir.create(file.path(OUTPUT_PATH, study_date, "Plots")))

#' source subfunctions
source(file.path(FUNC_PATH, "subfunctions.R"))

#' list all the GAMs (main.R generated one sub-directory per generated GAM)
dirs <- list.dirs(file.path(OUTPUT_PATH, study_date), recursive = F)
dirs <- dirs[-grep("Plots", dirs)]

#' dataframe which will contain the coefficients of all the GAMs
#' give 100 columns and delete the empty columns afterwards (no need to provide the number of coefficient as argument)
coef.df <- data.frame(matrix(ncol = 100, nrow = 0))

# list of dataframes of predicted values by each model
ct_int_pred <- list()

# vector with the R2 (deviance explained)
r_squares <- c()

if (cluster == F & VERBOSE == T){
  cat("Getting prediction from every model")
  
  pb <- txtProgressBar(max = length(dirs), style = 3)
}

for (i in 1:length(dirs)){
  
  if (cluster == F & VERBOSE == T){
    setTxtProgressBar(pb, i)
  }
  
  gam <- readRDS(file.path(dirs[i], grep("gam.*rds", list.files(dirs[i]), value = T)))
  
  #'@r-square
  r_squares[i] <- summary(gam)$dev.expl
  
  #'@factor_terms
  coef <- coefficients(gam)[-grep("lon|lat", names(coefficients(gam)))]
  coef.df <- rbind(coef.df, c(coef, rep(NA, 100-length(coef))))
  names(coef.df) <- names(coef)
  
  #'@spatial_term
  data <- gam$model
  
  # get the gam prediction, for every lat lon pair
  # with, for every other variable, the values chosen in the arguments
  ct_int_pred[[i]] <- expand_grid(
    lon = seq(from=xlm[1], 
              to=xlm[2], 
              length.out = xlm[2]-xlm[1]+1),
    lat = seq(from=ylm[1],
              to=ylm[2], 
              length.out = ylm[2]-ylm[1]+1),
    fishing_quarter = predict_var_values$fishing_quarter,
    fishing_year = predict_var_values$fishing_year,
    size_class = predict_var_values$size_class
  )
  
  ct_int_pred[[i]] <- predict(gam, newdata = ct_int_pred[[i]], se.fit = TRUE) %>%  
    as_tibble() %>% 
    cbind(ct_int_pred[[i]]) %>%
    dplyr::select(fit, lon, lat)
  
  # get the number of samples per cell
  data %>% mutate(lat_r = round(lat), lon_r = round(lon)) -> rdata
  
  table(rdata$lon_r, rdata$lat_r) %>% as.data.frame() %>%
    expand_grid() %>%
    rename("lon" = "Var1",
           "lat" = "Var2",
           "n_spl" = "Freq") %>%
    mutate(lat = as.numeric(as.character(lat)),
           lon = as.numeric(as.character(lon))) %>%
    as.data.frame() -> count_data
  
  merge(count_data, ct_int_pred[[i]], by = c("lon","lat"), all.y = T) %>%
    mutate(n_spl = ifelse(is.na(n_spl), 0, n_spl)) -> ct_int_pred[[i]]
}

if (cluster == F & VERBOSE == T){
  close(pb)
}

#'@factor_terms
cols <- !apply(coef.df, 2, function(x) all(is.na(x)))
coef.df <- coef.df[,cols]

#' @save the table with all the coefficients
write.csv(x = coef.df, file = coeffTableName)

#' @spatial_term
df_tot <- abind(ct_int_pred, along = 3)

len = length(dirs)
# len <- 500
if(len!=length(dirs)){df_tot <- df_tot[,,1:len]}

  #' limits of the colour scale and binwidth of the level lines
if (is.null(smooth_col_limits)){
  if(Kn_transformation){
    lims <- list(c(-0.3,0.3),
                 NULL,
                 c(0,.1),
                 NULL)
    bwidth <- c(0.25,NA,0.125,NA)
  } else {
    lims <- list(c(0.9,1.1),
                 NULL,
                 c(0,.1),
                 NULL)
    bwidth <- c(0.025, NA, 0.0125,NA)
  }
} else {
  lims <- list(smooth_col_limits,
               NULL,
               c(0,.1),
               NULL)
  bwidth <- c((lims[[1]][2]-lims[[1]][1])/8,
              NA,
              (lims[[2]][2]-lims[[2]][1])/8,
              NA)
}

col_titles <- paste(rep(c("Mean","Sd of"),each = 2),
                    c(paste0("predicted\n",ifelse(Kn_transformation, "T(Kn)", "Kn")),
                      "number\n of samples"))

  #' polygons of the land
countries <- map_data("world")

  #' functions of the maps to be plotted
f <- c("mean","sd")
variable <- c("fit", "n_spl")

df_list <- list()
plot_list <- list()

# df_nspl <- df_tot[,which(dimnames(df_tot)[[2]] == "n_spl"),]
# df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == "fit"),]
df_lon <- df_tot[,which(dimnames(df_tot)[[2]] == "lon"),]
df_lat <- df_tot[,which(dimnames(df_tot)[[2]] == "lat"),]

if (any(apply(df_lon, 1, function(x) length(unique(x))) != 1)){
  stop("Error: longitudinal range is not the same for all the predictions")
} else if (any(apply(df_lat, 1, function(x) length(unique(x))) != 1)){
  "Error: latitudinal range is not the same for all the predictions"
}

i=0
for (k in 1:length(f)){
  for (j in 1:length(variable)){
    i=i+1
    df_fit <- df_tot[,which(dimnames(df_tot)[[2]] == variable[j]),]
    
    col_fit <- apply(df_fit, 1, f[k])
    col_lon <- df_lon[,1]
    col_lat <- df_lat[,1]
    
    df_list[[i]] <- as.data.frame(cbind(fit = col_fit,
                                      lon = col_lon,
                                      lat = col_lat))
    
    
    #' @plot
    plot_list[[i]] <- ggplot(df_list[[i]], aes(x=lon, y=lat)) +
      coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
      geom_tile(aes(fill = fit), alpha = 0.8) +
      scale_fill_gradientn(col_titles[i], limits = lims[[i]], colors = c("blue","grey","red"))+
      geom_contour(aes(z = fit), binwidth = bwidth[i], colour = "grey40")+
      theme(panel.background = element_blank(),
            panel.border = element_rect(fill=NA))+
      geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
      xlab("Longitude")+ylab("Latitude")
    
    ggsave(latlonPlotNames[i], plot_list[[i]])
  }
}

# rm(col_fit, col_lon, col_lat, df_fit, df_lon, df_lat) ; invisible(gc())


#'******************************
#' Plots of the GAM coefficients
#'******************************
data_filtered <- readRDS(file.path(OUTPUT_PATH, study_date, "df_filtered.rds"))
p1 <- plot.coef.df(coef.df, "fishing_year", levels = levels(data_filtered$fishing_year),
                   level_ref = as.character(predict_var_values$fishing_year),
                   labelx = "Year",
                   output_path = file.path(OUTPUT_PATH, study_date))
p2 <- plot.coef.df(coef.df, "fishing_quarter", levels = levels(data_filtered$fishing_quarter),
                   level_ref = as.character(predict_var_values$fishing_quarter),
                   labelx = "Quarter",
                   output_path = file.path(OUTPUT_PATH, study_date))

ggsave(coefDfPlotNames[1], p1[[1]])
ggsave(coefDfPlotNames[2], p1[[2]])
ggsave(coefDfPlotNames[3], p2[[1]])
ggsave(coefDfPlotNames[4], p2[[2]])

global_plot_list <- list(plot_list[[1]], plot_list[[2]],
                         plot_list[[3]], plot_list[[4]],
                         p1[[1]],p1[[2]],
                         p2[[1]],p2[[2]])

if (size_class_for_model == 'all'){
  p3 <- plot.coef.df(coef.df, "size_class", levels = size_class_levels,
                     level_ref = as.character(predict_var_values$size_class),
                     labelx = "Size Class",
                     output_path = file.path(OUTPUT_PATH, study_date))
  ggsave(coefDfPlotNames[5], p3[[1]])
  ggsave(coefDfPlotNames[6], p3[[2]])
  
  global_plot_list <- append(global_plot_list, list(p3[[1]], p3[[2]]))
}

if (fad_fsc == T & fishing_mode_for_model == "all"){
  p4 <- plot.coef.df(coef.df, "fishing_mode", labelx = "School Type")
  ggsave(coefDfPlotNames[7], p4[[1]])
  ggsave(coefDfPlotNames[8], p4[[2]])
  
  global_plot_list <- append(global_plot_list, list(p4[[1]], p4[[2]]))
}


#' Save the list with all the ggplots
saveRDS(global_plot_list, plotListName)

#' Save the r-squares vector
saveRDS(r_squares, rSquareName)

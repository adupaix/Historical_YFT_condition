#'#*******************************************************************************************************************
#'@author : Amael DUPAIX
#'@update : 2021-11-17
#'@email : amael.dupaix@ens-lyon.fr
#'#*******************************************************************************************************************
#'@description :  Third part of the main script to determine if the YFT condition factor (Kn) has been
#' impacted by the introduction of FADs in the Indian Ocean.
#' This part summarizes all the GAMs generated by the first part (and potentially by the second part, which runs on the cluster)
#'#*******************************************************************************************************************
#' @tags:
#' the @for_study tag is used before each argument, to specify which arguments were used to obtain the study results
#'#*******************************************************************************************************************
#'@revisions
#'#*******************************************************************************************************************

rm(list = ls())
invisible(gc())

WD <- getwd()

DATA_PATH <- file.path(WD, "0.Data/")

FUNC_PATH <- file.path(WD,"1.Functions")
# OUTPUT_PATH <- file.path(WD, "3.Outputs", format(Sys.time()))
OUTPUT_PATH <- file.path(WD, "3.Outputs")
ROUT_PATH <- file.path(WD,"6.Sub-routines")

PLOT_PATH <- file.path(OUTPUT_PATH, "Plots")

#'@arguments:
#'#**********
#'
#' Name of the output folder which was generated by
#' the first part of the study (main.R & potentially main_cluster.R)
#' @for_study: format(Sys.Date())
study_date = "2021-11-23"
# study_date = format(Sys.Date())

#' Read the arguments of the first part of the study
arguments <- readRDS(file.path(OUTPUT_PATH, study_date, "README.rds"))
list2env(arguments, envir = .GlobalEnv)

#' If want to change the color scale limits compared to the one used in the main.R script
#' if NULL, the limits are c(0.9,1.1) if the GH transformation is not applied
#'                     or c(-1,1) if the GH transformation is applied
#' @for_study: c(-1,0)
smooth_col_limits = c(-1,0)
# smooth_col_limits = c(-1,0)

#' Values of the explanatory variables chosen to make the spatial prediction
#' @for_study: predict_var_values = list(fishing_quarter = "1",
#'                                       fishing_year = 2008,
#'                                       size_class = "<75")
#'                                       
predict_var_values = list(fishing_quarter = "1",
                          fishing_year = 1987,
                          size_class = "<75")

#' ***************
#' Get libraries:
#' ***************
source(file.path(FUNC_PATH, "install_libraries.R"))

srcUsedPackages <- c("plyr", "dplyr","tidyr","lubridate","sf", "ggplot2","tibble",
                     "cowplot","RColorBrewer", "MASS","truncnorm", "mgcv", "abind")

installAndLoad_packages(srcUsedPackages, loadPackages = TRUE, verbose = F)

# Generate the names of the outputs
latlonPlotNames <- c(file.path(OUTPUT_PATH, study_date, "mean_latlon_plot.png"),
                     file.path(OUTPUT_PATH, study_date, "sd_latlon_plot.png"))
coeffsPlotNames <- c(file.path(OUTPUT_PATH, study_date, "year_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "quarter_coeff.png"),
                     file.path(OUTPUT_PATH, study_date, "size_class_coeff.png"))
coeffTableName <- file.path(OUTPUT_PATH, study_date, "coeff_table.csv")

# main.R generated one sub-directory per generated GAM
dirs <- list.dirs(file.path(OUTPUT_PATH, study_date), recursive = F)
dirs <- dirs[-grep("Plots", dirs)]

# dataframe which will contain the coefficients of all the GAMs
coef.df <- data.frame(matrix(ncol = 100, nrow = 0))

# list of dataframes of predicted values by each model
ct_int_pred <- list()

# cat("Getting latitude and longitude range")
# pb <- txtProgressBar(max = length(dirs), style = 3)
# 
# maxs <- c(0,0)
# mins <- c(0,0)
# 
# for (i in 1:length(dirs)){
#   setTxtProgressBar(pb, i)
#   
#   gam <- readRDS(file.path(dirs[i], grep("gam.*rds", list.files(dirs[i]), value = T)))
#   
#   data <- gam$model
#   
#   min.x.i <- min(data$scaled_lon)
#   max.x.i <- max(data$scaled_lon)
#   min.y.i <- min(data$scaled_lat)
#   max.y.i <- max(data$scaled_lat)
#   
#   maxs.i <- c(max.x.i, max.y.i)
#   mins.i <- c(min.x.i, min.y.i)
#   
#   for (k in 1:2){
#     if (maxs.i[k] > maxs[k]){maxs.i[k] -> maxs[k]}
#     if (mins.i[k] < mins[k]){mins.i[k] -> mins[k] ; if(k==1){j <- i}}
#   }
# }
# 
# close(pb)

cat("Getting prediction from every model")

pb <- txtProgressBar(max = length(dirs), style = 3)

for (i in 1:length(dirs)){
  
  setTxtProgressBar(pb, i)
  
  gam <- readRDS(file.path(dirs[i], grep("gam.*rds", list.files(dirs[i]), value = T)))
  
  #'@factor_terms
  coef <- coefficients(gam)[-grep("scaled_", names(coefficients(gam)))]
  coef.df <- rbind(coef.df, c(coef, rep(NA, 100-length(coef))))
  names(coef.df) <- names(coef)
  
  #'@spatial_term
  data <- gam$model
  
  # get the gam prediction, for every lat lon pair
  # with, for every other variable, the values chosen in the arguments
  ct_int_pred[[i]] <- expand_grid(
    scaled_lon = seq(from=xlm[1], 
                     to=xlm[2], 
                     length.out = 50),
    scaled_lat = seq(from=ylm[1],
                     to=ylm[2], 
                     length.out = 50),
    fishing_quarter = predict_var_values$fishing_quarter,
    fishing_year = predict_var_values$fishing_year,
    size_class = predict_var_values$size_class
  )
  
  ct_int_pred[[i]] <- predict(gam, newdata = ct_int_pred[[i]], se.fit = TRUE) %>%  
    as_tibble() %>% 
    cbind(ct_int_pred[[i]]) %>%
    dplyr::select(fit, scaled_lon, scaled_lat)
  
}

close(pb)

#'@factor_terms
coef.df <- coef.df[-1,]
cols <- !apply(coef.df, 2, function(x) all(is.na(x)))
coef.df <- coef.df[,cols]

#' @save the table with all the coefficients
write.csv(x = coef.df, file = coeffTableName)

#' @spatial_term
df_tot <- abind(ct_int_pred, along = 3)

len <- 250
if(len!=length(dirs)){df_tot <- df_tot[,,1:len]}

  #'@formatting (to unscale lat and long inside the loop)
sc_lon <- attr(data$scaled_lon, "scaled:scale")
ce_lon <- attr(data$scaled_lon, "scaled:center")
sc_lat <- attr(data$scaled_lat, "scaled:scale")
ce_lat <- attr(data$scaled_lat, "scaled:center")

  #' limits of the colour scale and binwidth of the level lines
if (is.null(smooth_col_limits)){
  if(Kn_transformation){
    lims <- list(c(-1,1),
                 c(0,.1))
    bwidth <- c(0.25,0.125)
  } else {
    lims <- list(c(0.9,1.1),
                 c(0,.1))
    bwidth <- c(0.025,0.0125)
  }
} else {
  lims <- list(smooth_col_limits,
               c(0,.1))
  bwidth <- c((lims[[1]][2]-lims[[1]][1])/8,
              (lims[[2]][2]-lims[[2]][1])/8)
}

col_titles <- paste(c("Mean","Sd of"), paste0("predicted\n",ifelse(Kn_transformation, "T(Kn)", "Kn")))

  #' polygons of the land
countries <- map_data("world")

  #' functions of the maps to be plotted
f <- c("mean","sd")

df_list <- list()
plot_list <- list()

df_fit <- df_tot[,1,]
df_lon <- df_tot[,2,]
df_lat <- df_tot[,3,]

if (any(apply(df_lon, 1, function(x) length(unique(x))) != 1)){
  stop("Error: longitudinal range is not the same for all the predictions")
} else if (any(apply(df_lat, 1, function(x) length(unique(x))) != 1)){
  "Error: latitudinal range is not the same for all the predictions"
}

for (k in 1:length(f)){
  
  col_fit <- apply(df_fit, 1, f[k])
  col_lon <- df_lon[,1]
  col_lat <- df_lat[,1]
  
  df_list[[f[k]]] <- as.data.frame(cbind(fit = col_fit,
                                         scaled_lon = col_lon,
                                         scaled_lat = col_lat))
  
  df_list[[f[k]]] %>%
    mutate(lon = scaled_lon * sc_lon + ce_lon,
           lat = scaled_lat * sc_lat + ce_lat) -> df_list[[f[k]]]
  
  #' @plot
  plot_list[[f[k]]] <- ggplot(df_list[[f[k]]], aes(x=lon, y=lat)) +
    coord_sf(xlim = xlm, ylim = ylm, expand = FALSE, crs = st_crs(4326)) +
    geom_tile(aes(fill = fit), alpha = 0.8) +
    scale_fill_gradientn(col_titles[k], limits = lims[[k]], colors = c("blue","grey","red"))+
    geom_contour(aes(z = fit), binwidth = bwidth[[k]], colour = "grey40")+
    theme(panel.background = element_blank(),
          panel.border = element_rect(fill=NA))+
    geom_polygon(data=countries, aes(x=long, y=lat, group = group))+
    xlab("Longitude")+ylab("Latitude")
  
  ggsave(latlonPlotNames[k], plot_list[[f[k]]])
  ggsave(paste0(latlonPlotNames[k],len,".png"), plot_list[[f[k]]])
}

# rm(col_fit, col_lon, col_lat, df_fit, df_lon, df_lat) ; invisible(gc())

